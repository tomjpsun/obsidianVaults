這兩個 kernel API 都與封包的傳輸時間戳記 (timestamping) 有關，但它們的用途和使用時機不同：

---

### 1. `skb_tstamp_tx(struct sk_buff *orig_skb, struct skb_shared_hwtstamps *hwtstamps)`

**功能：**

- 當封包有關聯的 socket 時，這個函式會：
    - **複製 (clone) 原始封包**，而不是創建新的封包。
    - **儲存硬體時間戳記**（如果 `hwtstamps` 不為 `NULL`）。
    - **若沒有硬體時間戳記，則生成軟體時間戳記**。
    - **將封包放入 socket 的 error queue**，讓應用程式能夠獲取這些時間資訊。
- **錯誤會被靜默忽略 (silently ignored)**。

**使用時機：**

- **應用層相關**：這個函式主要用於 **socket 層的時間戳記處理**，通常是為了提供應用程式可用的封包發送時間資訊。
- **適用於 socket 層的時間同步機制，如 PTP (Precision Time Protocol) 等**。

---

### 2. `skb_tx_timestamp(struct sk_buff *skb)`

**功能：**

- 這個函式是專門提供給 **Ethernet MAC 驅動 (driver)** 使用的 **hook**，用來在網卡傳輸封包前打上時間戳記。
- 應該在 **硬體真正處理封包前** 調用，否則：
    - 封包可能會被釋放，導致無法獲取時間資訊。
    - 可能會影響 TX (傳輸) 完成的時機。

**使用時機：**

- **驅動層相關**：這個函式用於 **網路驅動的 `hard_xmit()` 階段**，通常由驅動程式在網卡硬體傳輸封包前調用。
- **確保封包發送時間可被記錄**，並且可以透過 `skb_tstamp_tx()` 進一步傳遞給應用層。

---

### **比較總結**

|API|主要用途|調用時機|影響範圍|
|---|---|---|---|
|`skb_tstamp_tx()`|讓 socket 層獲取發送時間戳記|封包發送後、放入 error queue|應用層|
|`skb_tx_timestamp()`|為 MAC 驅動提供發送時間戳記|`hard_xmit()` 之前|驅動層|

**簡單來說：**

- **`skb_tx_timestamp()` 是給網路驅動用的，負責記錄封包傳輸的時間戳記，確保封包在進入網卡前有紀錄。**
- **`skb_tstamp_tx()` 則是提供給 socket 層，讓應用程式可以取得發送的時間戳記。**

這兩個函式可能會搭配使用，例如：

1. **驅動程式** 先在 `hard_xmit()` 裡面調用 `skb_tx_timestamp()` 來處理時間戳記。
2. **之後，當封包發送成功時**，會用 `skb_tstamp_tx()` 把時間戳記傳給應用層。

如果你是做 **驅動開發**，那應該關注 `skb_tx_timestamp()`；如果是做 **應用層網路時間同步相關的開發**，則會用到 `skb_tstamp_tx()`。

# 爲什麼 skb_tstamp_tx 要 queue clone ?

`skb_tstamp_tx()` 會 **queue clone (複製封包後放入佇列)**，主要原因是 **確保時間戳記資訊不會因為原始封包的釋放而丟失**，以及 **避免影響原始封包的傳輸**。這背後涉及幾個關鍵點：

---

### **1. `sk_buff` (skb) 在發送後會被釋放**

在 Linux 網路堆疊中，封包 (`struct sk_buff`，簡稱 `skb`) 一旦被傳輸到網卡驅動並成功發送，通常會被釋放（free），這樣可以節省記憶體。但時間戳記資訊可能會稍後才需要，例如：

- 需要回傳給應用程式（透過 `SO_TIMESTAMPING` socket 選項）。
- 在 **精確時間同步 (PTP, Precision Time Protocol)** 中，用來計算時鐘偏差。

如果不 **clone**，原始 `skb` 可能已經被釋放，導致時間戳記資訊無法存取。

---

### **2. 共享 skb 內部資料，減少記憶體開銷**

- `skb_tstamp_tx()` **不會完全複製整個封包資料 (payload)**，而是 **clone 一個指向相同資料的 `skb`**，使得:
    - **原始封包可以繼續傳輸**。
    - **克隆的封包用於記錄時間戳記，並放入 socket error queue**。
- 這樣的方式**降低了記憶體與 CPU 負擔**，因為不需要完全複製封包內容。

> Clone `skb` 只會複製 `sk_buff` 結構，而不會複製 `skb->data`（即封包的實際內容），這使得時間戳記處理更有效率。

---

### **3. `SO_TIMESTAMPING` 需要傳遞時間戳記到 socket**

應用程式如果啟用了 `SO_TIMESTAMPING`，它會透過 socket **接收傳輸時間戳記**。這需要 **把封包 (或其時間戳記資訊) 放入 socket 的 error queue**，應用程式才讀得到：

```c
sock_queue_err_skb(sk, skb);
```

- 這就是 `skb_tstamp_tx()` 所做的事情，它 **clone 封包，並把它放入 socket 的錯誤佇列**。
- 若不 clone，原始 `skb` **可能早已被釋放**，導致應用層無法獲得時間資訊。

---

### **4. 避免影響原始封包的傳輸**

如果我們直接修改原始 `skb` 來存儲時間戳記，可能會有一些潛在問題：

- **封包可能正在傳輸**，不應該修改。
- **某些驅動或網路設備可能會依賴 `skb` 的完整性**，修改它可能會導致未知的問題。
- **多個層級的處理（驅動、協議、應用）可能需要不同的 `skb` 副本**。

因此，通過 clone `skb`，我們可以：

1. **保持原始封包的完整性**，避免影響網路傳輸。
2. **讓應用程式透過 socket error queue 獲取時間戳記**。

---

### **結論**

`skb_tstamp_tx()` queue clone 的主要目的是：

- **避免原始 `skb` 被釋放後導致時間戳記丟失**。
- **降低記憶體與 CPU 負擔**，因為只 clone `skb` 結構，而不複製完整封包數據。
- **讓應用程式能夠透過 socket error queue 讀取時間戳記**，用於 PTP、NTP 等時間同步機制。
- **確保原始封包不被修改，避免影響網路傳輸**。

這種設計在高效能網路協議和時間同步應用中非常重要，例如 PTP (IEEE 1588) 或其他高精度時間同步機制。